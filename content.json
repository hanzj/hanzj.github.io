[{"title":"mysql5.7多个timestamp字段error","date":"2017-08-27T16:00:00.000Z","path":"2017/08/28/mysql57-timestamp-error/","text":"在mysql5.7中，表中有多个timestamp字段时报以下error Invalid default value for ‘timestamp’ 解决方案： 修改/etc/my.cnf 12[mysqld]explicit_defaults_for_timestamp = true 参考：MySQL从5.5升级到5.6，TIMESTAMP的变化","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"oracle安装sample schema","date":"2017-07-17T06:50:27.153Z","path":"2017/07/17/oracle-install-sample/","text":"从github下载sample源码并上传至服务器https://github.com/oracle/db-sample-schemas/releases/tag/v12.2.0.1 12345678910[hanzj@localhost demo]$ pwd/app/oracle/base/product/12.2.0/dbhome_1/demo[hanzj@localhost demo]$ cp ~/db-sample-schemas-12.2.0.1.zip ./[hanzj@localhost demo]$ unzip db-sample-schemas-12.2.0.1.zip [hanzj@localhost demo]$ mv schema/ schema.bak[hanzj@localhost demo]$ lsdb-sample-schemas-12.2.0.1 db-sample-schemas-12.2.0.1.zip schema.bak[hanzj@localhost demo]$ mv db-sample-schemas-12.2.0.1 schema[hanzj@localhost demo]$ cd schema[hanzj@localhost schema]$ sed -i \"s#__SUB__CWD__#$(pwd)#g\" `grep __SUB__CWD__ -rl --include=\"*.sql\" ./` 查看mksample.sql中__SUB__CWD__是否已经替换为据对路径。然后以sysdba登陆oracle执行1@?/demo/schema/mksample xchzj xchzj xchzj xchzj xchzj xchzj xchzj xchzj users temp '/tmp/log/' localhost:1521/orcl 以上语句含义如下1234@?/demo/schema/mksample &lt;SYSTEM_password&gt; &lt;SYS_password&gt; &lt;HR_password&gt; &lt;OE_password&gt; &lt;PM_password&gt; &lt;IX_password&gt; &lt;SH_password&gt; &lt;BI_password&gt; default_tablespace temporary_tablespace log_file_directory connect_string","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"oracle常用函数","date":"2017-07-07T16:00:00.000Z","path":"2017/07/08/func/","text":"1. 字符类函数1.1. SCCII返回第一个字母的ASCII码12345SQL&gt; select ascii('abc') from dual ;ASCII('ABC')------------ 97 1.2. CHR返回数值对应的SCII字符12345SQL&gt; select chr(97) from dual ;CHR(97)-------a 1.3. CONCAT连接两个字符串，相当于 ‘a’ || ‘b’12345SQL&gt; select concat('a','b') from dual ;CONCAT('A','B')---------------ab 1.4. INITCAP每个单词首字母大写，其他字母小写12345SQL&gt; select initcap('aBC def') from dual ;INITCAP('ABCDEF')-----------------Abc Def 1.5. INSTR(c1,c2,i,n)从字符串c1的第i个字符串开始搜索c2出现第n次的位置1234567891011SQL&gt; select instr('abcabcabc','a','4',2) from dual ;INSTR('ABCABCABC','A','4',2)---------------------------- 7SQL&gt; select instr('abcabcabc','a','-3',2) from dual ;INSTR('ABCABCABC','A','-3',2)----------------------------- 4 1.6. LENGTH返回字符串长度12345SQL&gt; select length('abc') from dual ;LENGTH('ABC')------------- 3 1.7. UPPER 和 LOWER返回大/小写12345SQL&gt; select upper('a'),lower('B') from dual ;UPPER('A') LOWER('B')---------- ----------A b 1.8. LTRIM 和 RTRIM删除左边/右边出现的字符串12345SQL&gt; select ltrim(' abc'),ltrim(' abc','a'),ltrim('abc','a') from dual ;LTRIM('ABC') LTRIM('ABC','A') LTRIM('ABC','A')------------ ---------------- ----------------abc abc bc 1.9. TRIM去除两边的空格12345SQL&gt; select trim(' abca ') from dual ;TRIM('ABCA')------------abca 1.10. LPAD 和 RPAD在左边/右边填充字符串1234567891011SQL&gt; select lpad('abc',6,'*'),rpad('abc',6,'*') from dual ;LPAD('ABC',6,'*') RPAD('ABC',6,'*')----------------- -----------------***abc abc***SQL&gt; select lpad('abc',2,'*'),lpad('abc',2),rpad('abc',2,'*'),rpad('abc',2) from dual ;LPAD('ABC',2,'*') LPAD('ABC',2) RPAD('ABC',2,'*') RPAD('ABC',2)----------------- ------------- ----------------- -------------ab ab ab ab 1.11. SUBSTR(c,i[,j])从c的第i位开始截取长度为j的字符串，j为空截取到尾部，i为负从右边数第i位开始12345SQL&gt; select substr('abcdef',-4,2) from dual ;SUBSTR('ABCDEF',-4,2)---------------------cd 1.12. REPLACE(c1,c2[,c3])用c3替换c1中的c212345SQL&gt; select replace(&apos;abc&apos;,&apos;c&apos;),replace(&apos;abc&apos;,&apos;c&apos;,&apos;2&apos;) from dual ;REPLACE(&apos;ABC&apos;,&apos;C&apos;) REPLACE(&apos;ABC&apos;,&apos;C&apos;,&apos;2&apos;)------------------ ----------------------ab ab2 数字类函数 序号 函数 意义 01 ABS(n) 绝对值 02 CEIL(n) 大于等于n的最小整数 03 FLOOR(n) 小于等于n的最小整数 04 MOD(n1,n2) n1/n2 的余数 05 POWER(n1,n2) n1的n2次方 06 ROUND(n1,n2) 返回舍入小数点右边n2位的n1的值 07 SQRT(n) n的平方根 08 TRUNC(n1,n2) 用于返回截尾到n2位小数的n1的值 日期函数 序号 函数 意义 01 ADD_MONTHS(d,i) 日期d加上i个月 02 LAST_DAY(d) d月份的最后一天 03 MONTHS_BETWEEN(d1,d2) 间隔的月数 04 NEW_TIME(d1,tz1,tz2) 转换时区tz1的日期d1对应的tz2时区时间 05 SYSDATE 当前的系统时间","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"oracle数据字典","date":"2017-06-28T11:43:36.000Z","path":"2017/06/28/oracle-dict/","text":"查询用户下所有表SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = ‘BYD_PORTAL_BPM’; 查询表中所有字段SELECT * FROM All_Tab_Columns t WHERE t.TABLE_NAME = ‘ZZ_TEST’ ; 查询表的索引列SELECT * FROM SYS.ALL_IND_COLUMNS T WHERE UPPER(T.TABLE_NAME) = ‘ZZ_TEST’ 列出表中的约束SELECT * FROM All_Constraints t WHERE t.table_name = ‘ZZ_TEST’ 在oracle中描述数据字典视图SELECT table_name , comments FROM DICTIONARY WHERE table_name LIKE ‘%TABLE%’","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"maven实战","date":"2017-04-28T11:43:36.000Z","path":"2017/04/28/maven-practice/","text":"1. maven使用入门1.1. 编写POM123456789101112131415&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt; Maven hello-world project&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2. 编写主代码在src/main/java/下新建自己的包名，然后编写程序代码。代码编写完成后在项目根目录运行命令 mvn clean compile 进行编译。 1.3. 编写测试代码在src/test/java/下编写测试代码。执行命令 mvn clea test 测试代码。由于历史原因，Maven的核心插件之一–complier插件默认只编译java1.3，因此需要配置该插件使其支持更高更高版本的java。12345678910111213141516&lt;project&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.4. 打包和运行执行命令 mvn clean package 进行打包，默认类型为jar，在target目录下可以看到输出的jar。命令 mvn clean install ，会将输出的jar安装到本地Maven仓库。compile 、test、package、install是一个渐进的过程，执行后边的命令之前会执行前边的命令。为了生成可执行的jar，需要借助maven-shade-plugin，再次打包后即可通过java -jar 命令直接运行该jar1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt; &lt;mainClass&gt; com.juvenxu.mavenbook.helloworld.HelloWorld &lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2. 坐标和依赖2.1. 依赖范围maven项目有三种classpath（编译，测试和运行），依赖范围就是用来控制依赖和这三种classpath的关系： 依赖范围（Scope） 编译classpath有效 测试classpath有效 运行时classpath有效 例子 compile Y Y Y spring-core test - Y - JUnit provided Y Y - servlet-api runtime - Y Y JDBC驱动实现 system Y Y Y 本地的，Maven仓库之外的类库文件 2.2. 传递性依赖和依赖范围假如，A依赖B，B依赖C，我们就说A对B是第一直接依赖，B对C是第二直接依赖，A对C是传递性依赖。第一直接依赖范围和第二直接依赖范围决定了传递性依赖范围。左边第一列表示第一直接依赖范围，第一行表示第二直接依赖范围 \\ compile test provided runtime compile compile —– —– runtime test test —– —– test provided provided —– provided provided runtime runtime —– —– runtime 2.3. 依赖调解第一原则是：路径最近者优先：A&gt;B&gt;C&gt;X(1.0),A&gt;D&gt;X(2.0),那么2.0会 被解析。第二原则是：第一声明者优先：A&gt;B&gt;X(1.0),A&gt;C&gt;X(2.0) ,1.0在前所以解析1.0 2.4. 可选依赖&lt;optional&gt;true&lt;/optional&gt;表示依赖是可选依赖，可选依赖不会被传递。A&gt;B ，B&gt;X(可选) ，B&gt;Y(可选),X Y将不会对A产生任何影响。如果A又依赖于X，那么只能在A中显式的声明X。（为什么使用可选依赖？可能项目B有两种特性，特性一依赖于X ，特性二依赖于Y，这两个特性是互斥的，比如数据库驱动程序。） 2.5. 排除依赖项目A依赖项目B，项目B依赖项目C，但是由于一些原因不想引入项目C，而是自己显式的引入C 2.6. 优化依赖nihaomvn dependency:list 可以查看当前项目已解析依赖 mvn dependency:tree 可以查看项目的依赖树mvn dependency:analyze 可以帮助分析当前项目的依赖 3. 仓库3.1. 本地仓库localRepository可以设置自己想要定义的本地仓库地址，默认为~/.m2/repository1234 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | Default: $&#123;user.home&#125;/.m2/repository--&gt;&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; 3.2. 中央仓库1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 3.3. 远程仓库配置在很多情况下，默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另外一个远程仓库中，如:JBoss，Maven仓库。这时，可以在POM中配置该仓库，见代码请单：1234567891011121314&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;name&gt;JBoss Repository&lt;/name&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repositories&gt; 在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。任何一个仓库声明的id必须是唯一的，尤其需要注意的是，maven自带的中央仓库使用的id为central，如果其他的仓库声明也使用该id，就会覆盖中央仓库的配置。该例配置中的releases和snapshots元素比较重要，它们用来控制Maven对于发布版构件和快照版构件的下载。该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。该例中的layout元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy：12345&lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt; &lt;/snapshots&gt; 元素updatePolicy用来配置Maven从远程仓库检查更新的频率，默认的 值是daily，表示Maven每天检查一次。其他可用的值包括：never—从不检查更新；always—每次构建都检查更 新；interval:X—每隔X分钟检查一次更新(X为任意整数)。元素checksumPolicy用来配置Maven检查检验和文件的策略。当构件被部署到Maven仓库中时，会同时部署对应的校验和 文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，怎么办？当checksumPolicy的值为默认的warn时，Maven 会在执行构建时输出警告信息，其他可用的值包括：fail—Maven遇到校验和错误就让构建失败；ignore—使用Maven完全忽略校验和错误。 3.4. 远程仓库的认证假设需要为一个id为my-proj的仓库配置认证信息，编辑settings.xml文件见代码清单：1234567891011&lt;settings&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;my-proj&lt;/id&gt; &lt;username&gt;repo-user&lt;/username&gt; &lt;password&gt;repo-pwd&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; ... &lt;/settings&gt; settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致。 3.5. 部署至远程仓库Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构建部署到仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，见代码：12345678910111213141516&lt;project&gt; ... &lt;destributionManagement&gt; &lt;repository&gt; &lt;id&gt;proj-releases&lt;/id&gt; &lt;name&gt;Proj Release Repository&lt;/name&gt; &lt;url&gt;http://192.168.1.100/content/repositories/proj-releases&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;proj-snapshots&lt;/id&gt; &lt;name&gt;Proj Snapshot Repository&lt;/name&gt; &lt;url&gt;http://192.168.1.100/content/repositories/proj-snapshots&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/destributionManagement&gt; ... &lt;/project&gt; distributionManagement包含repository和snapshotRepository子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。往远程仓库部署构件的时候，往往需要认证。同4. 3.6. 镜像如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。换句话说，任何一个可以从仓库Y获得的构件，都胡够从它的镜像中获取。举个例子，http://maven.net.cn/content/groups/public/ 是中央仓库http://repo1.maven.org/maven2/ 在中国的镜像，由于地理位置的因素，该镜像往往能够提供比中央仓库更快的务。因此，可以配置Maven使用该镜像来替代中央仓库。编辑settings.xml，代码如下：12345678910111213141516171819202122232425262728&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;one of the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ... &lt;/settings&gt;``` `&lt;mirrorOf&gt;`的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像。任何需要的构件都可以从私服获得，私服就是所有仓库的镜像。这时，可以配置这样的一个镜像： ```xml&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;internal-repository&lt;/id&gt; &lt;name&gt;Internal Repository Manager&lt;/name&gt; &lt;url&gt;http://192.168.1.100/maven2&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ... &lt;/settings&gt; &lt;mirrorOf&gt;的值为星号，表示该配置是所有Maven仓库的镜像。为了满足一些复杂需求，maven还支持更高级的镜像配置：&lt;mirrorOf&gt;*&lt;/mirrorOf&gt; 匹配所有远程仓库。&lt;mirrorOf&gt;external:*&lt;/mirrorOf&gt;匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。&lt;mirrorOf&gt;repo1,repo2&lt;/mirrorOf&gt;匹配仓库repo1和repo2，使用逗号分隔多个远程仓库。&lt;mirrorOf&gt;*,!repo1&lt;/miiroOf&gt;匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。 4. 生命周期和插件4.1. 三套生命周期maven拥有三套项目独立的生命周期，他们分别是clean、default和site。clean声明周期的目的是清理项目，default声明周期的目的是构件项目，而site声明周期的目的是建立项目站点。 4.1.1. clean生命周期 clean生命周期的目的是清理项目，它包含三个阶段： 1）pre-clean 执行一些清理前需要完成的工作 2）clean 清理上一次构建生成的文件 3）post-clean 执行一些清理后需要完成的工作 4.1.2. default生命周期default生命周期定义了真正构建时所需要的所有步骤，它是这三个中最核心的部分，包含的阶段如下： 1)validate 验证项目是正确的并且所有必需的信息都是可用的 2)initialize 初始化构建状态 3)generate-sources 产生所有的用来编译的源代码 4)process-sources 处理源代码 5)generate-resources 产生包含在package中的资源 6)process-resources 复制和处理资源到目标目录，为打包做好准备 7)compile 编译项目的主源代码 8)process-classes 对编译器产生的文件进行后期处理 9)generate-test-sources 产生所有用来编译的测试源代码 10)process-test-sources 处理测试源代码 11)generate-test-resources 创建测试所需要的资源 12)process-test-resources 复制和处理资源到测试目标目录 13)compile 编译测试源代码到目标目录 14)process-test-classes 对编译测试源代码产生的文件进行后期处理 15)test 使用适当的单元测试框架运行测试，这些测试代码不应该被打包或者部署 16)prepare-package 执行所有需要执行的操作为打包做准备，这往往会产生一个还未打包的处理过的包版本 17)package 使用设置的方式对编译过的文件进行打包 18)pre-integration-test 执行一些集成测试执行前必须的操作 19)integration-test 处理和部署包到集成测试环境中，进行测试 20)post-integration-test 对集成测试进行后期处理 21)verify 执行所有检查确保包是正确的和符合质量要求的 22)install 安装包到本地仓库，为其他本地的项目提供依赖 23)deploy 发布包，拷贝最后的包到远程仓库中，为其他的开发任何项目提供使用 4.1.3. site声明周期site：建立和发布项目站点 1)pre-site 前期准备 2)site 产生项目的站点文档 3)post-site 后期处理 4)site-deploy 部署站点到服务器 4.2. 命令行与生命周期从命令行执行Maven任务的最主要方式就是调用Maven的生命周期阶段，需要注意的是，各个生命周期阶段是相互独立的，而一个生命周期的阶段是有前后依赖关系的，举几个例子：mvn clean 该命令调用clean生命周期的clean阶段。实际执行的阶段为clean生命周期的pre-clean和clean阶段mvn test 该命令调用default生命周期的test阶段。实际执行的阶段为default生命周期的直到test的所有阶段，这也解释了为什么在执行测试的时候，项目的代码能够自动得以编译mvn clean install 该命令调用clean生命周期的clean阶段和default生命周期的install阶段。实际执行的为clean生命周期的pre-clean、clean阶段以及default生命周期的直到install的所有阶段。该命令结合了两个生命周期，在执行真正地项目构建之前清理项目是一个很好的实践mvn clean deploy site-deploy 该命令调用clean生命周期的clean阶段，default生命周期的deploy阶段以及site生命周期的site-deploy阶段。实际执行的为clean生命周期的pre-clean,clean阶段以及default和site生命周期的所有阶段 4.3. 内置插件绑定clean生命周期阶段和插件目标的绑定关系 生命周期阶段 插件目标 pre-clean – clean maven-clean-plugin:clean post-clean – site生命周期阶段和插件目标的绑定关系 生命周期阶段 插件目标 pre-site – site maven-site-plugin:site post-site – site-deploy maven-site-plugin:deploy default生命周期的阶段与插件的目标绑定关系由项目打包类型所决定，jar类型（默认）的如下生命周期阶段 | 插件目标:——–: | :——–:process-resources | maven-resources-plugin:resourcescompile | maven-compiler-pugin:compileprocess-test-resources | maven-resources-plugin:testResourcestest-compile | maven-compiler-plugin:testCompiletest | maven-surefire-plugin:testCompilepackage | maven-jar-plugin:jarinstall | maven-install-plugin:installdeploy | maven-deploy-plugin:deploy default生命周期除jar外常见的还有war，pom，maven-plugin，ear等。 4.4. 自定义绑定1234567891011121314151617181920212223242526&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;buildSource&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;inherited&gt;false&lt;/inherited&gt; &lt;configuration&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 通过以上配置，再执行mvn verify，maven-source-plugin：jar-no-fork会得以执行，它会创建一个以-sources.jar结尾的源码文件包。 4.5. 配置插件Maven插件高度易扩展，可以方便的进行自定义配置。如：配置maven-compiler-plugin插件编译源代码的JDK版本为1.7：12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 4.6. POM中插件任务配置1234567891011121314151617181920212223242526272829303132333435&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;ant-validate&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;echo&gt;I'm bound to validate phase.&lt;/echo&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;ant-verify&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;echo&gt;I'm bound to verify phase.&lt;/echo&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在上述代码中，首先，mvaen-antrun-plugin:run与validate阶段绑定，从而构成一个id为ant-validate的任务。插件全局配置中的configuration元素位于plugin元素下面，而这里的configuration元素则位于execution元素下面，表示这是特定任务的配置，而非插件整体的配置。这个ant-validate任务配置了一个echo Act任务，向命令行输出一段文字，表示该任务是绑定到validate阶段的。第二个任务的id为ant-varify，它绑定到了verify阶段，同样它也输出一段文字到命令行，告诉我们任务绑定到了verify阶段。 4.7. 在线插件信息maven官方插件详细地址：http://maven.apache.org/plugins/index.html 4.8. 插件仓库123456789101112&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 5. 聚合和继承5.1. 聚合可以通过在一个打包方式为POM的Maven项目中声明任意数量的module元素来实现模块的聚合。这里每个module的值都是一个子模块POM相对于当前POM的相对路径。123456789101112&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt; pom &lt;/packaging&gt; &lt;name&gt;Account Aggregator&lt;/name&gt; &lt;modules&gt; &lt;module&gt;../account-email&lt;/module&gt; &lt;module&gt;../account-persist&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; account-email和account-persist分别是两个子模块的目录名。 5.2. 继承123456&lt;parent&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../account-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; relativePath表示父模块POM的相对路径，maven首先会根据relativePath检查父pom，如果找不到再从本地仓库找，默认值为 ../pom.xml 5.3. 可继承的POM元素groupId ：项目组 ID ，项目坐标的核心元素；version ：项目版本，项目坐标的核心元素； description ：项目的描述信息； organization ：项目的组织信息； inceptionYear ：项目的创始年份； url ：项目的 url 地址 develoers ：项目的开发者信息； contributors ：项目的贡献者信息； distributionManagerment ：项目的部署信息； issueManagement ：缺陷跟踪系统信息； ciManagement ：项目的持续继承信息； scm ：项目的版本控制信息； mailingListserv ：项目的邮件列表信息； properties ：自定义的 Maven 属性； dependencies ：项目的依赖配置； dependencyManagement ：醒目的依赖管理配置； repositories ：项目的仓库配置； build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等； reporting ：包括项目的报告输出目录配置、报告插件配置等。 5.4. 依赖管理父模块pom.xml1234567891011121314151617181920212223242526&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.x.demo&lt;/groupId&gt; &lt;artifactId&gt;demo-parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo-parent Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- dependencyManagement 定义的依赖 需要在子pom中声明 不然不会产生效果 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;modules&gt; &lt;module&gt;../demo-a&lt;/module&gt; &lt;module&gt;../demo-b&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 模块a123456789101112131415161718192021222324252627282930313233343536&lt;project &gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.x.demo&lt;/groupId&gt; &lt;artifactId&gt;demo-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../demo-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;demo-a&lt;/artifactId&gt; &lt;name&gt;demo-a Maven Webapp&lt;/name&gt; &lt;properties&gt; &lt;mail.version&gt;1.4.1&lt;/mail.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 声明父pom中的依赖 这样才会真正被使用 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 扩展依赖 父pom中并没有声明 不会影响到父POM 和其他模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;$&#123;mail.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;demo-a&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 模块b123456789101112131415&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.x.demo&lt;/groupId&gt; &lt;artifactId&gt;demo-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../demo-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;demo-b&lt;/artifactId&gt; &lt;name&gt;demo-a Maven Webapp&lt;/name&gt; &lt;!-- 没有声明父pom中的依赖 不会被使用 --&gt; &lt;build&gt; &lt;finalName&gt;demo-b&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 父POM 中使用dependencyManagement 声明的依赖不会给子模块引入依赖， 只会继承这段配置。在模块a(demo-a) pom中声明了父pom中junit依赖 在执行的时候才会获得真正的依赖信息。模块b(demo-b) pom中没有声明父pom中junit依赖 不会产生实际效果。 5.5. import依赖范围import依赖范围只在dependencyManagement元素下才有效，使用该范围的依赖通常指向一个pom，作用是将目标中的dependencyManagement配置导入并合并到当前pom的dependencyManagement元素中。1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 5.6. 插件管理使用pluginManagement替换dependencies，同依赖管理1234567891011121314151617181920&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;extensions&gt; &lt;extension&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 该元素中配置的依赖不会造成实际的插件调用行为，当pom中配置了真正的plugin元素，并且其groupId和artifactId与pluginManagement中配置的插件匹配时，pluginManagement的配置才会影响实际的插件行为。如果子模块不需要使用父模块中pluginManagement配置的插件，可以将其忽略或执行配置以覆盖父模块的pluginManagement配置。 5.7. 反应堆反应堆是指模块组成的一个构建结构，对于单模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承和依赖的关系，从而能够自动计算出合理的模块构建顺序。Maven实际的构建顺序是这样形成的：Maven读取pom，如果该pom没有依赖模块，那么久构建该模块，否则就先构建其依赖模块，如果该依赖模块还依赖于其他模块，则进一步先构建依赖的依赖。一般来说，用户会选择构建整个项目或者选择构建单个模块，但有些时候，用户会想要仅仅构建完整反应堆中 的某些模块。也就是说，需要实时的裁剪反应堆。maven提供很多命令行选项支持裁剪反应堆： -am, –also-make同时构建所列模块的依赖模块 -amd同时构建所依赖于所列模块的模块 -pl构建指定的模块，用，分开-rf从指定的模块回复反应堆","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Eclipse4.3.2 Unhandled event loop exception","date":"2017-04-05T15:01:12.613Z","path":"2017/04/05/Unhandled event loop exception/","text":"在使用Eclipse Kepler Service Release 2（4.3.2）安装插件的过程中，插件不能正常工作，并且在错误日志中输出Unhandled event loop exception。jdk使用的是64位1.8.2_65。google之说是软件冲突引起，关闭其它软件，问题依旧存在。 最后修改jdk版本为64位1.7.0_80，问题解决。","tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"dataTables SpringMVC 中的数据绑定","date":"2017-03-24T06:00:34.672Z","path":"2017/03/24/datatables-springmvc/","text":"在使用datatables通过ajax获取服务端数据时，因为datatables参数复杂，导致Spring MVC无法自动绑定对象。 前端报DataTables warning: table id=example1 - Ajax error. For more information about this error, please see http://datatables.net/tn/7 后台报警告: Handler execution resulted in exception: org.springframework.beans.InvalidPropertyException: Invalid property ‘columns[0][data]’ of bean class [...DataTable]: Property referenced in indexed property path ‘columns[0][data]’ is neither an array nor a List nor a Map; returned value was [...Columns@5ba60222]datatables提交的原始json格式如下：1234567891011121314151617181920212223242526272829303132&#123; \"draw\":1, \"columns\":[ &#123; \"data\":0, \"name\":\"\", \"searchable\":true, \"orderable\":false, \"search\":&#123; \"value\":\"\", \"regex\":false &#125; &#125;, &#123; \"data\":1, \"name\":\"\", \"searchable\":true, \"orderable\":false, \"search\":&#123; \"value\":\"\", \"regex\":false &#125; &#125; ], \"order\":[], \"start\":0, \"length\":-1, \"search\":&#123; \"value\":\"\", \"regex\":false &#125;&#125; jQuery Ajax会将上述json序列化成如下的字符串123456789101112131415161718draw=1&amp;columns[0][data]=0&amp;columns[0][name]=&amp;columns[0][searchable]=true&amp;columns[0][orderable]=false&amp;columns[0][search][value]=&amp;columns[0][search][regex]=false&amp;columns[1][data]=1,columns[1][name]=&amp;columns[1][searchable]=true&amp;columns[1][orderable]=false&amp;columns[1][search][value]=&amp;columns[1][search][regex]=false&amp;order=0&amp;start=0&amp;length=-1&amp;search[value]=&amp;search[regex]=false 对于一个对象object内部的字段field而言，转成object.field才是容易理解的，而object[field]，更让人理解为object是一个map集合对象。因此spring会将object[0][field]认为是List,object[0].field才会被认为是一个对象的字段。所以，解决方法就是重写jQuery的序列化方法，也就是buildParams方法，让column[0][data]变为column[0].data123456789101112131415161718192021222324252627282930313233343536function buildParams( prefix, obj, traditional, add ) &#123; var name; if ( jQuery.isArray( obj ) ) &#123; // Serialize array item. jQuery.each( obj, function( i, v ) &#123; if ( traditional || rbracket.test( prefix ) ) &#123; // Treat each array item as a scalar. add( prefix, v ); &#125; else &#123; // Item is non-scalar (array or object), encode its numeric index. buildParams( prefix + \"[\" + ( typeof v === \"object\" &amp;&amp; v != null ? i : \"\" ) + \"]\", v, traditional, add ); &#125; &#125; ); &#125; else if ( !traditional &amp;&amp; jQuery.type( obj ) === \"object\" ) &#123; // Serialize object item. for ( name in obj ) &#123; //buildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add ); buildParams( prefix + \".\" + name , obj[ name ], traditional, add ); &#125; &#125; else &#123; // Serialize scalar item. add( prefix, obj ); &#125;&#125; 参考：http://stackoverflow.com/questions/5900840/post-nested-object-to-spring-mvc-controller-using-json","tags":[{"name":"datatables","slug":"datatables","permalink":"http://yoursite.com/tags/datatables/"},{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"}]}]